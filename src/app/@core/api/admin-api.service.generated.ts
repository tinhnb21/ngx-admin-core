//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.2.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const ADMIN_API_BASE_URL = new InjectionToken<string>('ADMIN_API_BASE_URL');

@Injectable()
export class AdminApiAuthApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  login(body?: LoginRequest | undefined): Observable<AuthenticatedResult> {
    let url_ = this.baseUrl + "/api/admin/auth";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "text/plain"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processLogin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLogin(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<AuthenticatedResult>;
        }
      } else
        return _observableThrow(response_) as any as Observable<AuthenticatedResult>;
    }));
  }

  protected processLogin(response: HttpResponseBase): Observable<AuthenticatedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AuthenticatedResult.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AdminApiMediaApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @param type (optional)
   * @return Success
   */
  uploadImage(type?: string | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/media?";
    if (type !== undefined && type !== null)
      url_ += "type=" + encodeURIComponent("" + type) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUploadImage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUploadImage(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUploadImage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AdminApiPostApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createPost(body?: CreateUpdatePostRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/posts";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreatePost(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreatePost(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCreatePost(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @param body (optional)
   * @return Success
   */
  updatePost(id?: string | undefined, body?: CreateUpdatePostRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/posts?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdatePost(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdatePost(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdatePost(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  deletePosts(ids?: string[] | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/posts?";
    if (ids !== undefined && ids !== null)
      ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeletePosts(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeletePosts(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeletePosts(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param title (optional)
   * @param content (optional)
   * @param description (optional)
   * @param status (optional)
   * @param pageIndex (optional)
   * @param pageSize (optional)
   * @return Success
   */
  getPostsPaging(title?: string | null | undefined, content?: string | null | undefined, description?: string | null | undefined, status?: number | null | undefined, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<PostDtoPagedResult> {
    let url_ = this.baseUrl + "/api/admin/posts/paging?";
    if (title !== undefined && title !== null)
      url_ += "title=" + encodeURIComponent("" + title) + "&";
    if (content !== undefined && content !== null)
      url_ += "content=" + encodeURIComponent("" + content) + "&";
    if (description !== undefined && description !== null)
      url_ += "description=" + encodeURIComponent("" + description) + "&";
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&";
    if (pageIndex === null)
      throw new Error("The parameter 'pageIndex' cannot be null.");
    else if (pageIndex !== undefined)
      url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetPostsPaging(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetPostsPaging(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PostDtoPagedResult>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PostDtoPagedResult>;
    }));
  }

  protected processGetPostsPaging(response: HttpResponseBase): Observable<PostDtoPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PostDtoPagedResult.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getPostById(id: string): Observable<PostDto> {
    let url_ = this.baseUrl + "/api/admin/posts/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetPostById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetPostById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PostDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PostDto>;
    }));
  }

  protected processGetPostById(response: HttpResponseBase): Observable<PostDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PostDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AdminApiPropertiesApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @param title (optional)
   * @param bedRoom (optional)
   * @param livingRoom (optional)
   * @param address (optional)
   * @param provinceId (optional)
   * @param price (optional)
   * @param statusOfLandId (optional)
   * @param typeOfLandId (optional)
   * @param pageIndex (optional)
   * @param pageSize (optional)
   * @return Success
   */
  getPropertiesPaging(title?: string | null | undefined, bedRoom?: number | null | undefined, livingRoom?: number | null | undefined, address?: string | null | undefined, provinceId?: number | null | undefined, price?: number | null | undefined, statusOfLandId?: number | null | undefined, typeOfLandId?: number | null | undefined, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<PropertyDtoPagedResult> {
    let url_ = this.baseUrl + "/api/admin/properties/paging?";
    if (title !== undefined && title !== null)
      url_ += "Title=" + encodeURIComponent("" + title) + "&";
    if (bedRoom !== undefined && bedRoom !== null)
      url_ += "BedRoom=" + encodeURIComponent("" + bedRoom) + "&";
    if (livingRoom !== undefined && livingRoom !== null)
      url_ += "LivingRoom=" + encodeURIComponent("" + livingRoom) + "&";
    if (address !== undefined && address !== null)
      url_ += "Address=" + encodeURIComponent("" + address) + "&";
    if (provinceId !== undefined && provinceId !== null)
      url_ += "ProvinceId=" + encodeURIComponent("" + provinceId) + "&";
    if (price !== undefined && price !== null)
      url_ += "Price=" + encodeURIComponent("" + price) + "&";
    if (statusOfLandId !== undefined && statusOfLandId !== null)
      url_ += "StatusOfLandId=" + encodeURIComponent("" + statusOfLandId) + "&";
    if (typeOfLandId !== undefined && typeOfLandId !== null)
      url_ += "TypeOfLandId=" + encodeURIComponent("" + typeOfLandId) + "&";
    if (pageIndex === null)
      throw new Error("The parameter 'pageIndex' cannot be null.");
    else if (pageIndex !== undefined)
      url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetPropertiesPaging(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetPropertiesPaging(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PropertyDtoPagedResult>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PropertyDtoPagedResult>;
    }));
  }

  protected processGetPropertiesPaging(response: HttpResponseBase): Observable<PropertyDtoPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PropertyDtoPagedResult.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param title (optional)
   * @param description (optional)
   * @param bedRoom (optional)
   * @param restRoom (optional)
   * @param livingRoom (optional)
   * @param parkingLot (optional)
   * @param area (optional)
   * @param provinceId (optional)
   * @param address (optional)
   * @param price (optional)
   * @param year (optional)
   * @param statusOfLandId (optional)
   * @param typeOfLandId (optional)
   * @param imageFile (optional)
   * @param photoGallery (optional)
   * @return Success
   */
  createProperty(title?: string | undefined, description?: string | undefined, bedRoom?: number | undefined, restRoom?: number | undefined, livingRoom?: number | undefined, parkingLot?: number | undefined, area?: number | undefined, provinceId?: number | undefined, address?: string | undefined, price?: number | undefined, year?: number | undefined, statusOfLandId?: number | undefined, typeOfLandId?: number | undefined, imageFile?: FileParameter | undefined, photoGallery?: FileParameter[] | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/properties";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (title === null || title === undefined)
      throw new Error("The parameter 'title' cannot be null.");
    else
      content_.append("Title", title.toString());
    if (description === null || description === undefined)
      throw new Error("The parameter 'description' cannot be null.");
    else
      content_.append("Description", description.toString());
    if (bedRoom === null || bedRoom === undefined)
      throw new Error("The parameter 'bedRoom' cannot be null.");
    else
      content_.append("BedRoom", bedRoom.toString());
    if (restRoom === null || restRoom === undefined)
      throw new Error("The parameter 'restRoom' cannot be null.");
    else
      content_.append("RestRoom", restRoom.toString());
    if (livingRoom === null || livingRoom === undefined)
      throw new Error("The parameter 'livingRoom' cannot be null.");
    else
      content_.append("LivingRoom", livingRoom.toString());
    if (parkingLot === null || parkingLot === undefined)
      throw new Error("The parameter 'parkingLot' cannot be null.");
    else
      content_.append("ParkingLot", parkingLot.toString());
    if (area === null || area === undefined)
      throw new Error("The parameter 'area' cannot be null.");
    else
      content_.append("Area", area.toString());
    if (provinceId === null || provinceId === undefined)
      throw new Error("The parameter 'provinceId' cannot be null.");
    else
      content_.append("ProvinceId", provinceId.toString());
    if (address === null || address === undefined)
      throw new Error("The parameter 'address' cannot be null.");
    else
      content_.append("Address", address.toString());
    if (price === null || price === undefined)
      throw new Error("The parameter 'price' cannot be null.");
    else
      content_.append("Price", price.toString());
    if (year === null || year === undefined)
      throw new Error("The parameter 'year' cannot be null.");
    else
      content_.append("Year", year.toString());
    if (statusOfLandId === null || statusOfLandId === undefined)
      throw new Error("The parameter 'statusOfLandId' cannot be null.");
    else
      content_.append("StatusOfLandId", statusOfLandId.toString());
    if (typeOfLandId === null || typeOfLandId === undefined)
      throw new Error("The parameter 'typeOfLandId' cannot be null.");
    else
      content_.append("TypeOfLandId", typeOfLandId.toString());
    if (imageFile === null || imageFile === undefined)
      throw new Error("The parameter 'imageFile' cannot be null.");
    else
      content_.append("ImageFile", imageFile.data, imageFile.fileName ? imageFile.fileName : "ImageFile");
    if (photoGallery === null || photoGallery === undefined)
      throw new Error("The parameter 'photoGallery' cannot be null.");
    else
      photoGallery.forEach(item_ => content_.append("PhotoGallery", item_.data, item_.fileName ? item_.fileName : "PhotoGallery"));

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateProperty(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateProperty(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCreateProperty(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @param title (optional)
   * @param description (optional)
   * @param bedRoom (optional)
   * @param restRoom (optional)
   * @param livingRoom (optional)
   * @param parkingLot (optional)
   * @param area (optional)
   * @param provinceId (optional)
   * @param address (optional)
   * @param price (optional)
   * @param year (optional)
   * @param statusOfLandId (optional)
   * @param typeOfLandId (optional)
   * @param imageFile (optional)
   * @param photoGallery (optional)
   * @return Success
   */
  updateProperty(id?: string | undefined, title?: string | undefined, description?: string | undefined, bedRoom?: number | undefined, restRoom?: number | undefined, livingRoom?: number | undefined, parkingLot?: number | undefined, area?: number | undefined, provinceId?: number | undefined, address?: string | undefined, price?: number | undefined, year?: number | undefined, statusOfLandId?: number | undefined, typeOfLandId?: number | undefined, imageFile?: FileParameter | undefined, photoGallery?: FileParameter[] | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/properties?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (title === null || title === undefined)
      throw new Error("The parameter 'title' cannot be null.");
    else
      content_.append("Title", title.toString());
    if (description === null || description === undefined)
      throw new Error("The parameter 'description' cannot be null.");
    else
      content_.append("Description", description.toString());
    if (bedRoom === null || bedRoom === undefined)
      throw new Error("The parameter 'bedRoom' cannot be null.");
    else
      content_.append("BedRoom", bedRoom.toString());
    if (restRoom === null || restRoom === undefined)
      throw new Error("The parameter 'restRoom' cannot be null.");
    else
      content_.append("RestRoom", restRoom.toString());
    if (livingRoom === null || livingRoom === undefined)
      throw new Error("The parameter 'livingRoom' cannot be null.");
    else
      content_.append("LivingRoom", livingRoom.toString());
    if (parkingLot === null || parkingLot === undefined)
      throw new Error("The parameter 'parkingLot' cannot be null.");
    else
      content_.append("ParkingLot", parkingLot.toString());
    if (area === null || area === undefined)
      throw new Error("The parameter 'area' cannot be null.");
    else
      content_.append("Area", area.toString());
    if (provinceId === null || provinceId === undefined)
      throw new Error("The parameter 'provinceId' cannot be null.");
    else
      content_.append("ProvinceId", provinceId.toString());
    if (address === null || address === undefined)
      throw new Error("The parameter 'address' cannot be null.");
    else
      content_.append("Address", address.toString());
    if (price === null || price === undefined)
      throw new Error("The parameter 'price' cannot be null.");
    else
      content_.append("Price", price.toString());
    if (year === null || year === undefined)
      throw new Error("The parameter 'year' cannot be null.");
    else
      content_.append("Year", year.toString());
    if (statusOfLandId === null || statusOfLandId === undefined)
      throw new Error("The parameter 'statusOfLandId' cannot be null.");
    else
      content_.append("StatusOfLandId", statusOfLandId.toString());
    if (typeOfLandId === null || typeOfLandId === undefined)
      throw new Error("The parameter 'typeOfLandId' cannot be null.");
    else
      content_.append("TypeOfLandId", typeOfLandId.toString());
    if (imageFile === null || imageFile === undefined)
      throw new Error("The parameter 'imageFile' cannot be null.");
    else
      content_.append("ImageFile", imageFile.data, imageFile.fileName ? imageFile.fileName : "ImageFile");
    if (photoGallery === null || photoGallery === undefined)
      throw new Error("The parameter 'photoGallery' cannot be null.");
    else
      photoGallery.forEach(item_ => content_.append("PhotoGallery", item_.data, item_.fileName ? item_.fileName : "PhotoGallery"));

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateProperty(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateProperty(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdateProperty(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteProperty(id?: string | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/properties?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteProperty(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteProperty(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeleteProperty(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getPropertyById(id: string): Observable<PropertyDto> {
    let url_ = this.baseUrl + "/api/admin/properties/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetPropertyById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetPropertyById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PropertyDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PropertyDto>;
    }));
  }

  protected processGetPropertyById(response: HttpResponseBase): Observable<PropertyDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PropertyDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AdminApiProvincesApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createProvince(body?: CreateUpdateProvinceRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/provinces";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateProvince(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateProvince(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCreateProvince(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @param body (optional)
   * @return Success
   */
  updateProvince(id?: number | undefined, body?: CreateUpdateProvinceRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/provinces?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateProvince(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateProvince(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdateProvince(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteProvince(id?: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/provinces?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteProvince(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteProvince(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeleteProvince(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param name (optional)
   * @param code (optional)
   * @param status (optional)
   * @param pageIndex (optional)
   * @param pageSize (optional)
   * @return Success
   */
  getProvincePaging(name?: string | null | undefined, code?: string | null | undefined, status?: number | null | undefined, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<ProvinceDtoPagedResult> {
    let url_ = this.baseUrl + "/api/admin/provinces/paging?";
    if (name !== undefined && name !== null)
      url_ += "name=" + encodeURIComponent("" + name) + "&";
    if (code !== undefined && code !== null)
      url_ += "code=" + encodeURIComponent("" + code) + "&";
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&";
    if (pageIndex === null)
      throw new Error("The parameter 'pageIndex' cannot be null.");
    else if (pageIndex !== undefined)
      url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetProvincePaging(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetProvincePaging(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ProvinceDtoPagedResult>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ProvinceDtoPagedResult>;
    }));
  }

  protected processGetProvincePaging(response: HttpResponseBase): Observable<ProvinceDtoPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProvinceDtoPagedResult.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getProvinceById(id: number): Observable<ProvinceDto> {
    let url_ = this.baseUrl + "/api/admin/provinces/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetProvinceById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetProvinceById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ProvinceDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ProvinceDto>;
    }));
  }

  protected processGetProvinceById(response: HttpResponseBase): Observable<ProvinceDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProvinceDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AdminApiRoleApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createRole(body?: CreateUpdateRoleRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/role";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateRole(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateRole(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCreateRole(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @param body (optional)
   * @return Success
   */
  updateRole(id?: string | undefined, body?: CreateUpdateRoleRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/role?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateRole(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateRole(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdateRole(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  deleteRoles(ids?: string[] | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/role?";
    if (ids !== undefined && ids !== null)
      ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteRoles(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteRoles(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeleteRoles(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getRoleById(id: string): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/admin/role/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetRoleById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetRoleById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RoleDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RoleDto>;
    }));
  }

  protected processGetRoleById(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RoleDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param name (optional)
   * @param displayName (optional)
   * @param pageIndex (optional)
   * @param pageSize (optional)
   * @return Success
   */
  getRolesAllPaging(name?: string | null | undefined, displayName?: string | null | undefined, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<RoleDtoPagedResult> {
    let url_ = this.baseUrl + "/api/admin/role/paging?";
    if (name !== undefined && name !== null)
      url_ += "name=" + encodeURIComponent("" + name) + "&";
    if (displayName !== undefined && displayName !== null)
      url_ += "displayName=" + encodeURIComponent("" + displayName) + "&";
    if (pageIndex === null)
      throw new Error("The parameter 'pageIndex' cannot be null.");
    else if (pageIndex !== undefined)
      url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetRolesAllPaging(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetRolesAllPaging(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RoleDtoPagedResult>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RoleDtoPagedResult>;
    }));
  }

  protected processGetRolesAllPaging(response: HttpResponseBase): Observable<RoleDtoPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RoleDtoPagedResult.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAllRoles(): Observable<RoleDto[]> {
    let url_ = this.baseUrl + "/api/admin/role/all";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetAllRoles(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAllRoles(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RoleDto[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RoleDto[]>;
    }));
  }

  protected processGetAllRoles(response: HttpResponseBase): Observable<RoleDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(RoleDto.fromJS(item));
        }
        else {
          result200 = <any>null;
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAllRolePermissions(roleId: string | null): Observable<PermissionDto> {
    let url_ = this.baseUrl + "/api/admin/role/{roleId}/permissions";
    if (roleId === undefined || roleId === null)
      throw new Error("The parameter 'roleId' must be defined.");
    url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetAllRolePermissions(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAllRolePermissions(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PermissionDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PermissionDto>;
    }));
  }

  protected processGetAllRolePermissions(response: HttpResponseBase): Observable<PermissionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = PermissionDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  savePermission(body?: PermissionDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/role/permissions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processSavePermission(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSavePermission(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processSavePermission(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AdminApiSlideApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @param title (optional)
   * @param propertyId (optional)
   * @param isShow (optional)
   * @param imageFile (optional)
   * @return Success
   */
  createSlide(title?: string | undefined, propertyId?: string | undefined, isShow?: boolean | undefined, imageFile?: FileParameter | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/slides";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (title === null || title === undefined)
      throw new Error("The parameter 'title' cannot be null.");
    else
      content_.append("Title", title.toString());
    if (propertyId === null || propertyId === undefined)
      throw new Error("The parameter 'propertyId' cannot be null.");
    else
      content_.append("PropertyId", propertyId.toString());
    if (isShow === null || isShow === undefined)
      throw new Error("The parameter 'isShow' cannot be null.");
    else
      content_.append("IsShow", isShow.toString());
    if (imageFile === null || imageFile === undefined)
      throw new Error("The parameter 'imageFile' cannot be null.");
    else
      content_.append("ImageFile", imageFile.data, imageFile.fileName ? imageFile.fileName : "ImageFile");

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateSlide(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateSlide(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCreateSlide(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @param title (optional)
   * @param propertyId (optional)
   * @param isShow (optional)
   * @param imageFile (optional)
   * @return Success
   */
  updateSlide(id?: string | undefined, title?: string | undefined, propertyId?: string | undefined, isShow?: boolean | undefined, imageFile?: FileParameter | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/slides?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (title === null || title === undefined)
      throw new Error("The parameter 'title' cannot be null.");
    else
      content_.append("Title", title.toString());
    if (propertyId === null || propertyId === undefined)
      throw new Error("The parameter 'propertyId' cannot be null.");
    else
      content_.append("PropertyId", propertyId.toString());
    if (isShow === null || isShow === undefined)
      throw new Error("The parameter 'isShow' cannot be null.");
    else
      content_.append("IsShow", isShow.toString());
    if (imageFile === null || imageFile === undefined)
      throw new Error("The parameter 'imageFile' cannot be null.");
    else
      content_.append("ImageFile", imageFile.data, imageFile.fileName ? imageFile.fileName : "ImageFile");

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateSlide(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateSlide(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdateSlide(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteSlide(id?: string | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/slides?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteSlide(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteSlide(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeleteSlide(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param title (optional)
   * @param pageIndex (optional)
   * @param pageSize (optional)
   * @return Success
   */
  getSlidePaging(title?: string | null | undefined, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<SlideDtoPagedResult> {
    let url_ = this.baseUrl + "/api/admin/slides/paging?";
    if (title !== undefined && title !== null)
      url_ += "title=" + encodeURIComponent("" + title) + "&";
    if (pageIndex === null)
      throw new Error("The parameter 'pageIndex' cannot be null.");
    else if (pageIndex !== undefined)
      url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetSlidePaging(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetSlidePaging(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<SlideDtoPagedResult>;
        }
      } else
        return _observableThrow(response_) as any as Observable<SlideDtoPagedResult>;
    }));
  }

  protected processGetSlidePaging(response: HttpResponseBase): Observable<SlideDtoPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SlideDtoPagedResult.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getSlideById(id: string): Observable<SlideDto> {
    let url_ = this.baseUrl + "/api/admin/slides/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetSlideById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetSlideById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<SlideDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<SlideDto>;
    }));
  }

  protected processGetSlideById(response: HttpResponseBase): Observable<SlideDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SlideDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AdminApiStatusOfLandApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createStatusOfLand(body?: CreateUpdateStatusOfLandRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/status-of-lands";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateStatusOfLand(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateStatusOfLand(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCreateStatusOfLand(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @param body (optional)
   * @return Success
   */
  updateStatusOfLand(id?: number | undefined, body?: CreateUpdateStatusOfLandRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/status-of-lands?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateStatusOfLand(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateStatusOfLand(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdateStatusOfLand(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteStatusOfLand(id?: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/status-of-lands?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteStatusOfLand(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteStatusOfLand(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeleteStatusOfLand(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param name (optional)
   * @param description (optional)
   * @param status (optional)
   * @param pageIndex (optional)
   * @param pageSize (optional)
   * @return Success
   */
  getStatusOfLandPaging(name?: string | null | undefined, description?: string | null | undefined, status?: number | null | undefined, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<StatusOfLandDtoPagedResult> {
    let url_ = this.baseUrl + "/api/admin/status-of-lands/paging?";
    if (name !== undefined && name !== null)
      url_ += "name=" + encodeURIComponent("" + name) + "&";
    if (description !== undefined && description !== null)
      url_ += "description=" + encodeURIComponent("" + description) + "&";
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&";
    if (pageIndex === null)
      throw new Error("The parameter 'pageIndex' cannot be null.");
    else if (pageIndex !== undefined)
      url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetStatusOfLandPaging(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetStatusOfLandPaging(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StatusOfLandDtoPagedResult>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StatusOfLandDtoPagedResult>;
    }));
  }

  protected processGetStatusOfLandPaging(response: HttpResponseBase): Observable<StatusOfLandDtoPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = StatusOfLandDtoPagedResult.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getStatusOfLandById(id: number): Observable<StatusOfLandDto> {
    let url_ = this.baseUrl + "/api/admin/status-of-lands/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetStatusOfLandById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetStatusOfLandById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StatusOfLandDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StatusOfLandDto>;
    }));
  }

  protected processGetStatusOfLandById(response: HttpResponseBase): Observable<StatusOfLandDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = StatusOfLandDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AdminApiTokenApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  refresh(body?: TokenRequest | undefined): Observable<AuthenticatedResult> {
    let url_ = this.baseUrl + "/api/admin/token/refresh";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "text/plain"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processRefresh(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRefresh(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<AuthenticatedResult>;
        }
      } else
        return _observableThrow(response_) as any as Observable<AuthenticatedResult>;
    }));
  }

  protected processRefresh(response: HttpResponseBase): Observable<AuthenticatedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AuthenticatedResult.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  revoke(): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/token/revoke";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processRevoke(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRevoke(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processRevoke(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AdminApiTypeOfLandApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createTypeOfLand(body?: CreateUpdateTypeOfLandRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/type-of-lands";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateTypeOfLand(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateTypeOfLand(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCreateTypeOfLand(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @param body (optional)
   * @return Success
   */
  updateTypeOfLand(id?: number | undefined, body?: CreateUpdateTypeOfLandRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/type-of-lands?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateTypeOfLand(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateTypeOfLand(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdateTypeOfLand(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  deleteTypeOfLand(id?: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/type-of-lands?";
    if (id === null)
      throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteTypeOfLand(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteTypeOfLand(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeleteTypeOfLand(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param name (optional)
   * @param description (optional)
   * @param status (optional)
   * @param pageIndex (optional)
   * @param pageSize (optional)
   * @return Success
   */
  getTypeOfLandPaging(name?: string | null | undefined, description?: string | null | undefined, status?: number | null | undefined, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<TypeOfLandDtoPagedResult> {
    let url_ = this.baseUrl + "/api/admin/type-of-lands/paging?";
    if (name !== undefined && name !== null)
      url_ += "name=" + encodeURIComponent("" + name) + "&";
    if (description !== undefined && description !== null)
      url_ += "description=" + encodeURIComponent("" + description) + "&";
    if (status !== undefined && status !== null)
      url_ += "status=" + encodeURIComponent("" + status) + "&";
    if (pageIndex === null)
      throw new Error("The parameter 'pageIndex' cannot be null.");
    else if (pageIndex !== undefined)
      url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetTypeOfLandPaging(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetTypeOfLandPaging(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<TypeOfLandDtoPagedResult>;
        }
      } else
        return _observableThrow(response_) as any as Observable<TypeOfLandDtoPagedResult>;
    }));
  }

  protected processGetTypeOfLandPaging(response: HttpResponseBase): Observable<TypeOfLandDtoPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TypeOfLandDtoPagedResult.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getTypeOfLandById(id: number): Observable<TypeOfLandDto> {
    let url_ = this.baseUrl + "/api/admin/type-of-lands/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetTypeOfLandById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetTypeOfLandById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<TypeOfLandDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<TypeOfLandDto>;
    }));
  }

  protected processGetTypeOfLandById(response: HttpResponseBase): Observable<TypeOfLandDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TypeOfLandDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class AdminApiUserApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @return Success
   */
  getUserById(id: string): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/admin/user/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetUserById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetUserById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UserDto>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UserDto>;
    }));
  }

  protected processGetUserById(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserDto.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  updateUser(id: string, body?: UpdateUserRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/user/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUpdateUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processUpdateUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param fullName (optional)
   * @param userName (optional)
   * @param email (optional)
   * @param phoneNumber (optional)
   * @param isActive (optional)
   * @param pageIndex (optional)
   * @param pageSize (optional)
   * @return Success
   */
  getAllUsersPaging(fullName?: string | null | undefined, userName?: string | null | undefined, email?: string | null | undefined, phoneNumber?: string | null | undefined, isActive?: boolean | null | undefined, pageIndex?: number | undefined, pageSize?: number | undefined): Observable<UserDtoPagedResult> {
    let url_ = this.baseUrl + "/api/admin/user/paging?";
    if (fullName !== undefined && fullName !== null)
      url_ += "FullName=" + encodeURIComponent("" + fullName) + "&";
    if (userName !== undefined && userName !== null)
      url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
    if (email !== undefined && email !== null)
      url_ += "Email=" + encodeURIComponent("" + email) + "&";
    if (phoneNumber !== undefined && phoneNumber !== null)
      url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
    if (isActive !== undefined && isActive !== null)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (pageIndex === null)
      throw new Error("The parameter 'pageIndex' cannot be null.");
    else if (pageIndex !== undefined)
      url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "text/plain"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetAllUsersPaging(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAllUsersPaging(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UserDtoPagedResult>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UserDtoPagedResult>;
    }));
  }

  protected processGetAllUsersPaging(response: HttpResponseBase): Observable<UserDtoPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserDtoPagedResult.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createUser(body?: CreateUserRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/user";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processCreateUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCreateUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param ids (optional)
   * @return Success
   */
  deleteUsers(ids?: string[] | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/user?";
    if (ids !== undefined && ids !== null)
      ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDeleteUsers(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDeleteUsers(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processDeleteUsers(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeMyPassWord(body?: ChangeMyPasswordRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/user/password-change-current-user";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processChangeMyPassWord(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processChangeMyPassWord(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processChangeMyPassWord(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  setPassword(id: string, body?: SetPasswordRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/user/set-password/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processSetPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSetPassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processSetPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeEmail(id: string, body?: ChangeEmailRequest | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/user/change-email/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processChangeEmail(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processChangeEmail(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processChangeEmail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  assignRolesToUser(id: string | null, body?: string[] | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/admin/user/{id}/assign-users";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processAssignRolesToUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAssignRolesToUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAssignRolesToUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return _observableOf(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export class AuthenticatedResult implements IAuthenticatedResult {
  token?: string | undefined;
  refreshToken?: string | undefined;

  constructor(data?: IAuthenticatedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.token = _data["token"];
      this.refreshToken = _data["refreshToken"];
    }
  }

  static fromJS(data: any): AuthenticatedResult {
    data = typeof data === 'object' ? data : {};
    let result = new AuthenticatedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["token"] = this.token;
    data["refreshToken"] = this.refreshToken;
    return data;
  }
}

export interface IAuthenticatedResult {
  token?: string | undefined;
  refreshToken?: string | undefined;
}

export class ChangeEmailRequest implements IChangeEmailRequest {
  email?: string | undefined;

  constructor(data?: IChangeEmailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): ChangeEmailRequest {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeEmailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["email"] = this.email;
    return data;
  }
}

export interface IChangeEmailRequest {
  email?: string | undefined;
}

export class ChangeMyPasswordRequest implements IChangeMyPasswordRequest {
  oldPassword?: string | undefined;
  newPassword?: string | undefined;

  constructor(data?: IChangeMyPasswordRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.oldPassword = _data["oldPassword"];
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): ChangeMyPasswordRequest {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeMyPasswordRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["oldPassword"] = this.oldPassword;
    data["newPassword"] = this.newPassword;
    return data;
  }
}

export interface IChangeMyPasswordRequest {
  oldPassword?: string | undefined;
  newPassword?: string | undefined;
}

export class CreateUpdatePostRequest implements ICreateUpdatePostRequest {
  title!: string;
  slug!: string;
  description!: string;
  image!: string;
  publishDate!: Date;
  content!: string;
  status!: PostStatus;
  seoDescription!: string;

  constructor(data?: ICreateUpdatePostRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
      this.slug = _data["slug"];
      this.description = _data["description"];
      this.image = _data["image"];
      this.publishDate = _data["publishDate"] ? new Date(_data["publishDate"].toString()) : <any>undefined;
      this.content = _data["content"];
      this.status = _data["status"];
      this.seoDescription = _data["seoDescription"];
    }
  }

  static fromJS(data: any): CreateUpdatePostRequest {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUpdatePostRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["title"] = this.title;
    data["slug"] = this.slug;
    data["description"] = this.description;
    data["image"] = this.image;
    data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
    data["content"] = this.content;
    data["status"] = this.status;
    data["seoDescription"] = this.seoDescription;
    return data;
  }
}

export interface ICreateUpdatePostRequest {
  title: string;
  slug: string;
  description: string;
  image: string;
  publishDate: Date;
  content: string;
  status: PostStatus;
  seoDescription: string;
}

export class CreateUpdateProvinceRequest implements ICreateUpdateProvinceRequest {
  code!: string;
  name!: string;
  status!: TypeStatus;
  sortOrder?: number | undefined;

  constructor(data?: ICreateUpdateProvinceRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data["code"];
      this.name = _data["name"];
      this.status = _data["status"];
      this.sortOrder = _data["sortOrder"];
    }
  }

  static fromJS(data: any): CreateUpdateProvinceRequest {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUpdateProvinceRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["code"] = this.code;
    data["name"] = this.name;
    data["status"] = this.status;
    data["sortOrder"] = this.sortOrder;
    return data;
  }
}

export interface ICreateUpdateProvinceRequest {
  code: string;
  name: string;
  status: TypeStatus;
  sortOrder?: number | undefined;
}

export class CreateUpdateRoleRequest implements ICreateUpdateRoleRequest {
  name?: string | undefined;
  displayName?: string | undefined;

  constructor(data?: ICreateUpdateRoleRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
    }
  }

  static fromJS(data: any): CreateUpdateRoleRequest {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUpdateRoleRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    return data;
  }
}

export interface ICreateUpdateRoleRequest {
  name?: string | undefined;
  displayName?: string | undefined;
}

export class CreateUpdateStatusOfLandRequest implements ICreateUpdateStatusOfLandRequest {
  name!: string;
  description?: string | undefined;
  status!: TypeStatus;
  order?: number | undefined;

  constructor(data?: ICreateUpdateStatusOfLandRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.status = _data["status"];
      this.order = _data["order"];
    }
  }

  static fromJS(data: any): CreateUpdateStatusOfLandRequest {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUpdateStatusOfLandRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["status"] = this.status;
    data["order"] = this.order;
    return data;
  }
}

export interface ICreateUpdateStatusOfLandRequest {
  name: string;
  description?: string | undefined;
  status: TypeStatus;
  order?: number | undefined;
}

export class CreateUpdateTypeOfLandRequest implements ICreateUpdateTypeOfLandRequest {
  name!: string;
  description?: string | undefined;
  status!: TypeStatus;
  order?: number | undefined;

  constructor(data?: ICreateUpdateTypeOfLandRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.status = _data["status"];
      this.order = _data["order"];
    }
  }

  static fromJS(data: any): CreateUpdateTypeOfLandRequest {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUpdateTypeOfLandRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["status"] = this.status;
    data["order"] = this.order;
    return data;
  }
}

export interface ICreateUpdateTypeOfLandRequest {
  name: string;
  description?: string | undefined;
  status: TypeStatus;
  order?: number | undefined;
}

export class CreateUserRequest implements ICreateUserRequest {
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  password?: string | undefined;
  dob?: Date | undefined;
  avatar?: string | undefined;
  isActive?: boolean;

  constructor(data?: ICreateUserRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.userName = _data["userName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.password = _data["password"];
      this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
      this.avatar = _data["avatar"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): CreateUserRequest {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["userName"] = this.userName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["password"] = this.password;
    data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
    data["avatar"] = this.avatar;
    data["isActive"] = this.isActive;
    return data;
  }
}

export interface ICreateUserRequest {
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  password?: string | undefined;
  dob?: Date | undefined;
  avatar?: string | undefined;
  isActive?: boolean;
}

export class LoginRequest implements ILoginRequest {
  userName?: string | undefined;
  password?: string | undefined;

  constructor(data?: ILoginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data["userName"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): LoginRequest {
    data = typeof data === 'object' ? data : {};
    let result = new LoginRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["userName"] = this.userName;
    data["password"] = this.password;
    return data;
  }
}

export interface ILoginRequest {
  userName?: string | undefined;
  password?: string | undefined;
}

export class PermissionDto implements IPermissionDto {
  roleId?: string | undefined;
  roleClaims?: RoleClaimsDto[] | undefined;

  constructor(data?: IPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roleId = _data["roleId"];
      if (Array.isArray(_data["roleClaims"])) {
        this.roleClaims = [] as any;
        for (let item of _data["roleClaims"])
          this.roleClaims!.push(RoleClaimsDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PermissionDto {
    data = typeof data === 'object' ? data : {};
    let result = new PermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["roleId"] = this.roleId;
    if (Array.isArray(this.roleClaims)) {
      data["roleClaims"] = [];
      for (let item of this.roleClaims)
        data["roleClaims"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPermissionDto {
  roleId?: string | undefined;
  roleClaims?: RoleClaimsDto[] | undefined;
}

export class PostDto implements IPostDto {
  id?: string;
  title?: string | undefined;
  slug?: string | undefined;
  description?: string | undefined;
  image?: string | undefined;
  publishDate?: Date;
  content?: string | undefined;
  status?: PostStatus;
  seoDescription?: string | undefined;

  constructor(data?: IPostDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.title = _data["title"];
      this.slug = _data["slug"];
      this.description = _data["description"];
      this.image = _data["image"];
      this.publishDate = _data["publishDate"] ? new Date(_data["publishDate"].toString()) : <any>undefined;
      this.content = _data["content"];
      this.status = _data["status"];
      this.seoDescription = _data["seoDescription"];
    }
  }

  static fromJS(data: any): PostDto {
    data = typeof data === 'object' ? data : {};
    let result = new PostDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["title"] = this.title;
    data["slug"] = this.slug;
    data["description"] = this.description;
    data["image"] = this.image;
    data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
    data["content"] = this.content;
    data["status"] = this.status;
    data["seoDescription"] = this.seoDescription;
    return data;
  }
}

export interface IPostDto {
  id?: string;
  title?: string | undefined;
  slug?: string | undefined;
  description?: string | undefined;
  image?: string | undefined;
  publishDate?: Date;
  content?: string | undefined;
  status?: PostStatus;
  seoDescription?: string | undefined;
}

export class PostDtoPagedResult implements IPostDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  readonly firstRowOnPage?: number;
  readonly lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: PostDto[] | undefined;

  constructor(data?: IPostDtoPagedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPage = _data["currentPage"];
      this.pageCount = _data["pageCount"];
      this.pageSize = _data["pageSize"];
      this.rowCount = _data["rowCount"];
      (<any>this).firstRowOnPage = _data["firstRowOnPage"];
      (<any>this).lastRowOnPage = _data["lastRowOnPage"];
      this.additionalData = _data["additionalData"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(PostDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PostDtoPagedResult {
    data = typeof data === 'object' ? data : {};
    let result = new PostDtoPagedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currentPage"] = this.currentPage;
    data["pageCount"] = this.pageCount;
    data["pageSize"] = this.pageSize;
    data["rowCount"] = this.rowCount;
    data["firstRowOnPage"] = this.firstRowOnPage;
    data["lastRowOnPage"] = this.lastRowOnPage;
    data["additionalData"] = this.additionalData;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results)
        data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPostDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  firstRowOnPage?: number;
  lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: PostDto[] | undefined;
}

export enum PostStatus {
  _0 = 0,
  _1 = 1,
  _2 = 2,
}

export class PropertyDto implements IPropertyDto {
  id?: string;
  title?: string | undefined;
  description?: string | undefined;
  bedRoom?: number;
  restRoom?: number;
  livingRoom?: number;
  parkingLot?: number | undefined;
  area?: number;
  video?: string | undefined;
  image?: string | undefined;
  longtitude?: number | undefined;
  latitude?: number | undefined;
  comforts?: number | undefined;
  provinceId?: number;
  address?: string | undefined;
  price?: number;
  statusOfLandId?: number;
  year?: number;
  typeOfLandId?: number;
  createdDate?: Date;
  createdBy?: string;
  updatedDate?: Date | undefined;
  updatedBy?: string | undefined;
  statusName?: string | undefined;
  typeName?: string | undefined;
  propertyImages?: PropertyImage[] | undefined;

  constructor(data?: IPropertyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.title = _data["title"];
      this.description = _data["description"];
      this.bedRoom = _data["bedRoom"];
      this.restRoom = _data["restRoom"];
      this.livingRoom = _data["livingRoom"];
      this.parkingLot = _data["parkingLot"];
      this.area = _data["area"];
      this.video = _data["video"];
      this.image = _data["image"];
      this.longtitude = _data["longtitude"];
      this.latitude = _data["latitude"];
      this.comforts = _data["comforts"];
      this.provinceId = _data["provinceId"];
      this.address = _data["address"];
      this.price = _data["price"];
      this.statusOfLandId = _data["statusOfLandId"];
      this.year = _data["year"];
      this.typeOfLandId = _data["typeOfLandId"];
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
      this.updatedBy = _data["updatedBy"];
      this.statusName = _data["statusName"];
      this.typeName = _data["typeName"];
      if (Array.isArray(_data["propertyImages"])) {
        this.propertyImages = [] as any;
        for (let item of _data["propertyImages"])
          this.propertyImages!.push(PropertyImage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PropertyDto {
    data = typeof data === 'object' ? data : {};
    let result = new PropertyDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["title"] = this.title;
    data["description"] = this.description;
    data["bedRoom"] = this.bedRoom;
    data["restRoom"] = this.restRoom;
    data["livingRoom"] = this.livingRoom;
    data["parkingLot"] = this.parkingLot;
    data["area"] = this.area;
    data["video"] = this.video;
    data["image"] = this.image;
    data["longtitude"] = this.longtitude;
    data["latitude"] = this.latitude;
    data["comforts"] = this.comforts;
    data["provinceId"] = this.provinceId;
    data["address"] = this.address;
    data["price"] = this.price;
    data["statusOfLandId"] = this.statusOfLandId;
    data["year"] = this.year;
    data["typeOfLandId"] = this.typeOfLandId;
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
    data["updatedBy"] = this.updatedBy;
    data["statusName"] = this.statusName;
    data["typeName"] = this.typeName;
    if (Array.isArray(this.propertyImages)) {
      data["propertyImages"] = [];
      for (let item of this.propertyImages)
        data["propertyImages"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPropertyDto {
  id?: string;
  title?: string | undefined;
  description?: string | undefined;
  bedRoom?: number;
  restRoom?: number;
  livingRoom?: number;
  parkingLot?: number | undefined;
  area?: number;
  video?: string | undefined;
  image?: string | undefined;
  longtitude?: number | undefined;
  latitude?: number | undefined;
  comforts?: number | undefined;
  provinceId?: number;
  address?: string | undefined;
  price?: number;
  statusOfLandId?: number;
  year?: number;
  typeOfLandId?: number;
  createdDate?: Date;
  createdBy?: string;
  updatedDate?: Date | undefined;
  updatedBy?: string | undefined;
  statusName?: string | undefined;
  typeName?: string | undefined;
  propertyImages?: PropertyImage[] | undefined;
}

export class PropertyDtoPagedResult implements IPropertyDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  readonly firstRowOnPage?: number;
  readonly lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: PropertyDto[] | undefined;

  constructor(data?: IPropertyDtoPagedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPage = _data["currentPage"];
      this.pageCount = _data["pageCount"];
      this.pageSize = _data["pageSize"];
      this.rowCount = _data["rowCount"];
      (<any>this).firstRowOnPage = _data["firstRowOnPage"];
      (<any>this).lastRowOnPage = _data["lastRowOnPage"];
      this.additionalData = _data["additionalData"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(PropertyDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PropertyDtoPagedResult {
    data = typeof data === 'object' ? data : {};
    let result = new PropertyDtoPagedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currentPage"] = this.currentPage;
    data["pageCount"] = this.pageCount;
    data["pageSize"] = this.pageSize;
    data["rowCount"] = this.rowCount;
    data["firstRowOnPage"] = this.firstRowOnPage;
    data["lastRowOnPage"] = this.lastRowOnPage;
    data["additionalData"] = this.additionalData;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results)
        data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IPropertyDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  firstRowOnPage?: number;
  lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: PropertyDto[] | undefined;
}

export class PropertyImage implements IPropertyImage {
  id?: string;
  fileName!: string;
  link!: string;
  propertyId!: string;

  constructor(data?: IPropertyImage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.fileName = _data["fileName"];
      this.link = _data["link"];
      this.propertyId = _data["propertyId"];
    }
  }

  static fromJS(data: any): PropertyImage {
    data = typeof data === 'object' ? data : {};
    let result = new PropertyImage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["fileName"] = this.fileName;
    data["link"] = this.link;
    data["propertyId"] = this.propertyId;
    return data;
  }
}

export interface IPropertyImage {
  id?: string;
  fileName: string;
  link: string;
  propertyId: string;
}

export class ProvinceDto implements IProvinceDto {
  id?: number;
  code?: string | undefined;
  name?: string | undefined;
  status?: TypeStatus;
  sortOrder?: number | undefined;

  constructor(data?: IProvinceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.code = _data["code"];
      this.name = _data["name"];
      this.status = _data["status"];
      this.sortOrder = _data["sortOrder"];
    }
  }

  static fromJS(data: any): ProvinceDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProvinceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["code"] = this.code;
    data["name"] = this.name;
    data["status"] = this.status;
    data["sortOrder"] = this.sortOrder;
    return data;
  }
}

export interface IProvinceDto {
  id?: number;
  code?: string | undefined;
  name?: string | undefined;
  status?: TypeStatus;
  sortOrder?: number | undefined;
}

export class ProvinceDtoPagedResult implements IProvinceDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  readonly firstRowOnPage?: number;
  readonly lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: ProvinceDto[] | undefined;

  constructor(data?: IProvinceDtoPagedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPage = _data["currentPage"];
      this.pageCount = _data["pageCount"];
      this.pageSize = _data["pageSize"];
      this.rowCount = _data["rowCount"];
      (<any>this).firstRowOnPage = _data["firstRowOnPage"];
      (<any>this).lastRowOnPage = _data["lastRowOnPage"];
      this.additionalData = _data["additionalData"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(ProvinceDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProvinceDtoPagedResult {
    data = typeof data === 'object' ? data : {};
    let result = new ProvinceDtoPagedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currentPage"] = this.currentPage;
    data["pageCount"] = this.pageCount;
    data["pageSize"] = this.pageSize;
    data["rowCount"] = this.rowCount;
    data["firstRowOnPage"] = this.firstRowOnPage;
    data["lastRowOnPage"] = this.lastRowOnPage;
    data["additionalData"] = this.additionalData;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results)
        data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IProvinceDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  firstRowOnPage?: number;
  lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: ProvinceDto[] | undefined;
}

export class RoleClaimsDto implements IRoleClaimsDto {
  type?: string | undefined;
  value?: string | undefined;
  displayName?: string | undefined;
  selected?: boolean;

  constructor(data?: IRoleClaimsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.value = _data["value"];
      this.displayName = _data["displayName"];
      this.selected = _data["selected"];
    }
  }

  static fromJS(data: any): RoleClaimsDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleClaimsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["type"] = this.type;
    data["value"] = this.value;
    data["displayName"] = this.displayName;
    data["selected"] = this.selected;
    return data;
  }
}

export interface IRoleClaimsDto {
  type?: string | undefined;
  value?: string | undefined;
  displayName?: string | undefined;
  selected?: boolean;
}

export class RoleDto implements IRoleDto {
  id?: string;
  name?: string | undefined;
  displayName?: string | undefined;

  constructor(data?: IRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
    }
  }

  static fromJS(data: any): RoleDto {
    data = typeof data === 'object' ? data : {};
    let result = new RoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    return data;
  }
}

export interface IRoleDto {
  id?: string;
  name?: string | undefined;
  displayName?: string | undefined;
}

export class RoleDtoPagedResult implements IRoleDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  readonly firstRowOnPage?: number;
  readonly lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: RoleDto[] | undefined;

  constructor(data?: IRoleDtoPagedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPage = _data["currentPage"];
      this.pageCount = _data["pageCount"];
      this.pageSize = _data["pageSize"];
      this.rowCount = _data["rowCount"];
      (<any>this).firstRowOnPage = _data["firstRowOnPage"];
      (<any>this).lastRowOnPage = _data["lastRowOnPage"];
      this.additionalData = _data["additionalData"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(RoleDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleDtoPagedResult {
    data = typeof data === 'object' ? data : {};
    let result = new RoleDtoPagedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currentPage"] = this.currentPage;
    data["pageCount"] = this.pageCount;
    data["pageSize"] = this.pageSize;
    data["rowCount"] = this.rowCount;
    data["firstRowOnPage"] = this.firstRowOnPage;
    data["lastRowOnPage"] = this.lastRowOnPage;
    data["additionalData"] = this.additionalData;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results)
        data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IRoleDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  firstRowOnPage?: number;
  lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: RoleDto[] | undefined;
}

export class SetPasswordRequest implements ISetPasswordRequest {
  newPassword?: string | undefined;

  constructor(data?: ISetPasswordRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): SetPasswordRequest {
    data = typeof data === 'object' ? data : {};
    let result = new SetPasswordRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["newPassword"] = this.newPassword;
    return data;
  }
}

export interface ISetPasswordRequest {
  newPassword?: string | undefined;
}

export class SlideDto implements ISlideDto {
  id?: string;
  title?: string | undefined;
  image?: string | undefined;
  propertyId?: string;
  isShow?: boolean;
  propertyTitle?: string | undefined;

  constructor(data?: ISlideDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.title = _data["title"];
      this.image = _data["image"];
      this.propertyId = _data["propertyId"];
      this.isShow = _data["isShow"];
      this.propertyTitle = _data["propertyTitle"];
    }
  }

  static fromJS(data: any): SlideDto {
    data = typeof data === 'object' ? data : {};
    let result = new SlideDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["title"] = this.title;
    data["image"] = this.image;
    data["propertyId"] = this.propertyId;
    data["isShow"] = this.isShow;
    data["propertyTitle"] = this.propertyTitle;
    return data;
  }
}

export interface ISlideDto {
  id?: string;
  title?: string | undefined;
  image?: string | undefined;
  propertyId?: string;
  isShow?: boolean;
  propertyTitle?: string | undefined;
}

export class SlideDtoPagedResult implements ISlideDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  readonly firstRowOnPage?: number;
  readonly lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: SlideDto[] | undefined;

  constructor(data?: ISlideDtoPagedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPage = _data["currentPage"];
      this.pageCount = _data["pageCount"];
      this.pageSize = _data["pageSize"];
      this.rowCount = _data["rowCount"];
      (<any>this).firstRowOnPage = _data["firstRowOnPage"];
      (<any>this).lastRowOnPage = _data["lastRowOnPage"];
      this.additionalData = _data["additionalData"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(SlideDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SlideDtoPagedResult {
    data = typeof data === 'object' ? data : {};
    let result = new SlideDtoPagedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currentPage"] = this.currentPage;
    data["pageCount"] = this.pageCount;
    data["pageSize"] = this.pageSize;
    data["rowCount"] = this.rowCount;
    data["firstRowOnPage"] = this.firstRowOnPage;
    data["lastRowOnPage"] = this.lastRowOnPage;
    data["additionalData"] = this.additionalData;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results)
        data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface ISlideDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  firstRowOnPage?: number;
  lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: SlideDto[] | undefined;
}

export class StatusOfLandDto implements IStatusOfLandDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  status?: TypeStatus;
  order?: number | undefined;
  createdDate?: Date;
  createdBy?: string;
  updatedDate?: Date | undefined;
  updatedBy?: string | undefined;

  constructor(data?: IStatusOfLandDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.status = _data["status"];
      this.order = _data["order"];
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
      this.updatedBy = _data["updatedBy"];
    }
  }

  static fromJS(data: any): StatusOfLandDto {
    data = typeof data === 'object' ? data : {};
    let result = new StatusOfLandDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["description"] = this.description;
    data["status"] = this.status;
    data["order"] = this.order;
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
    data["updatedBy"] = this.updatedBy;
    return data;
  }
}

export interface IStatusOfLandDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  status?: TypeStatus;
  order?: number | undefined;
  createdDate?: Date;
  createdBy?: string;
  updatedDate?: Date | undefined;
  updatedBy?: string | undefined;
}

export class StatusOfLandDtoPagedResult implements IStatusOfLandDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  readonly firstRowOnPage?: number;
  readonly lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: StatusOfLandDto[] | undefined;

  constructor(data?: IStatusOfLandDtoPagedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPage = _data["currentPage"];
      this.pageCount = _data["pageCount"];
      this.pageSize = _data["pageSize"];
      this.rowCount = _data["rowCount"];
      (<any>this).firstRowOnPage = _data["firstRowOnPage"];
      (<any>this).lastRowOnPage = _data["lastRowOnPage"];
      this.additionalData = _data["additionalData"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(StatusOfLandDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): StatusOfLandDtoPagedResult {
    data = typeof data === 'object' ? data : {};
    let result = new StatusOfLandDtoPagedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currentPage"] = this.currentPage;
    data["pageCount"] = this.pageCount;
    data["pageSize"] = this.pageSize;
    data["rowCount"] = this.rowCount;
    data["firstRowOnPage"] = this.firstRowOnPage;
    data["lastRowOnPage"] = this.lastRowOnPage;
    data["additionalData"] = this.additionalData;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results)
        data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IStatusOfLandDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  firstRowOnPage?: number;
  lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: StatusOfLandDto[] | undefined;
}

export class TokenRequest implements ITokenRequest {
  accessToken?: string | undefined;
  refreshToken?: string | undefined;

  constructor(data?: ITokenRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"];
      this.refreshToken = _data["refreshToken"];
    }
  }

  static fromJS(data: any): TokenRequest {
    data = typeof data === 'object' ? data : {};
    let result = new TokenRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["accessToken"] = this.accessToken;
    data["refreshToken"] = this.refreshToken;
    return data;
  }
}

export interface ITokenRequest {
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
}

export class TypeOfLandDto implements ITypeOfLandDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  status?: TypeStatus;
  order?: number | undefined;
  createdDate?: Date;
  createdBy?: string;
  updatedDate?: Date | undefined;
  updatedBy?: string | undefined;

  constructor(data?: ITypeOfLandDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.status = _data["status"];
      this.order = _data["order"];
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.createdBy = _data["createdBy"];
      this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
      this.updatedBy = _data["updatedBy"];
    }
  }

  static fromJS(data: any): TypeOfLandDto {
    data = typeof data === 'object' ? data : {};
    let result = new TypeOfLandDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["description"] = this.description;
    data["status"] = this.status;
    data["order"] = this.order;
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["createdBy"] = this.createdBy;
    data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
    data["updatedBy"] = this.updatedBy;
    return data;
  }
}

export interface ITypeOfLandDto {
  id?: number;
  name?: string | undefined;
  description?: string | undefined;
  status?: TypeStatus;
  order?: number | undefined;
  createdDate?: Date;
  createdBy?: string;
  updatedDate?: Date | undefined;
  updatedBy?: string | undefined;
}

export class TypeOfLandDtoPagedResult implements ITypeOfLandDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  readonly firstRowOnPage?: number;
  readonly lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: TypeOfLandDto[] | undefined;

  constructor(data?: ITypeOfLandDtoPagedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPage = _data["currentPage"];
      this.pageCount = _data["pageCount"];
      this.pageSize = _data["pageSize"];
      this.rowCount = _data["rowCount"];
      (<any>this).firstRowOnPage = _data["firstRowOnPage"];
      (<any>this).lastRowOnPage = _data["lastRowOnPage"];
      this.additionalData = _data["additionalData"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(TypeOfLandDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TypeOfLandDtoPagedResult {
    data = typeof data === 'object' ? data : {};
    let result = new TypeOfLandDtoPagedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currentPage"] = this.currentPage;
    data["pageCount"] = this.pageCount;
    data["pageSize"] = this.pageSize;
    data["rowCount"] = this.rowCount;
    data["firstRowOnPage"] = this.firstRowOnPage;
    data["lastRowOnPage"] = this.lastRowOnPage;
    data["additionalData"] = this.additionalData;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results)
        data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface ITypeOfLandDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  firstRowOnPage?: number;
  lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: TypeOfLandDto[] | undefined;
}

export enum TypeStatus {
  _0 = 0,
  _1 = 1,
}

export class UpdateUserRequest implements IUpdateUserRequest {
  firstName?: string | undefined;
  lastName?: string | undefined;
  phoneNumber?: string | undefined;
  dob?: Date | undefined;
  avatar?: string | undefined;
  isActive?: boolean;

  constructor(data?: IUpdateUserRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.phoneNumber = _data["phoneNumber"];
      this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
      this.avatar = _data["avatar"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): UpdateUserRequest {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["phoneNumber"] = this.phoneNumber;
    data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
    data["avatar"] = this.avatar;
    data["isActive"] = this.isActive;
    return data;
  }
}

export interface IUpdateUserRequest {
  firstName?: string | undefined;
  lastName?: string | undefined;
  phoneNumber?: string | undefined;
  dob?: Date | undefined;
  avatar?: string | undefined;
  isActive?: boolean;
}

export class UserDto implements IUserDto {
  id?: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  dateCreated?: Date;
  isActive?: boolean;
  roles?: string[] | undefined;
  dob?: Date | undefined;
  avatar?: string | undefined;
  vipStartDate?: Date | undefined;
  vipExpireDate?: Date | undefined;
  lastLoginDate?: Date | undefined;

  constructor(data?: IUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.userName = _data["userName"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
      this.isActive = _data["isActive"];
      if (Array.isArray(_data["roles"])) {
        this.roles = [] as any;
        for (let item of _data["roles"])
          this.roles!.push(item);
      }
      this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
      this.avatar = _data["avatar"];
      this.vipStartDate = _data["vipStartDate"] ? new Date(_data["vipStartDate"].toString()) : <any>undefined;
      this.vipExpireDate = _data["vipExpireDate"] ? new Date(_data["vipExpireDate"].toString()) : <any>undefined;
      this.lastLoginDate = _data["lastLoginDate"] ? new Date(_data["lastLoginDate"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): UserDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["userName"] = this.userName;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
    data["isActive"] = this.isActive;
    if (Array.isArray(this.roles)) {
      data["roles"] = [];
      for (let item of this.roles)
        data["roles"].push(item);
    }
    data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
    data["avatar"] = this.avatar;
    data["vipStartDate"] = this.vipStartDate ? this.vipStartDate.toISOString() : <any>undefined;
    data["vipExpireDate"] = this.vipExpireDate ? this.vipExpireDate.toISOString() : <any>undefined;
    data["lastLoginDate"] = this.lastLoginDate ? this.lastLoginDate.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUserDto {
  id?: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  dateCreated?: Date;
  isActive?: boolean;
  roles?: string[] | undefined;
  dob?: Date | undefined;
  avatar?: string | undefined;
  vipStartDate?: Date | undefined;
  vipExpireDate?: Date | undefined;
  lastLoginDate?: Date | undefined;
}

export class UserDtoPagedResult implements IUserDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  readonly firstRowOnPage?: number;
  readonly lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: UserDto[] | undefined;

  constructor(data?: IUserDtoPagedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPage = _data["currentPage"];
      this.pageCount = _data["pageCount"];
      this.pageSize = _data["pageSize"];
      this.rowCount = _data["rowCount"];
      (<any>this).firstRowOnPage = _data["firstRowOnPage"];
      (<any>this).lastRowOnPage = _data["lastRowOnPage"];
      this.additionalData = _data["additionalData"];
      if (Array.isArray(_data["results"])) {
        this.results = [] as any;
        for (let item of _data["results"])
          this.results!.push(UserDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserDtoPagedResult {
    data = typeof data === 'object' ? data : {};
    let result = new UserDtoPagedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currentPage"] = this.currentPage;
    data["pageCount"] = this.pageCount;
    data["pageSize"] = this.pageSize;
    data["rowCount"] = this.rowCount;
    data["firstRowOnPage"] = this.firstRowOnPage;
    data["lastRowOnPage"] = this.lastRowOnPage;
    data["additionalData"] = this.additionalData;
    if (Array.isArray(this.results)) {
      data["results"] = [];
      for (let item of this.results)
        data["results"].push(item.toJSON());
    }
    return data;
  }
}

export interface IUserDtoPagedResult {
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  rowCount?: number;
  firstRowOnPage?: number;
  lastRowOnPage?: number;
  additionalData?: string | undefined;
  results?: UserDto[] | undefined;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export class SwaggerException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  return _observableThrow(new SwaggerException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
